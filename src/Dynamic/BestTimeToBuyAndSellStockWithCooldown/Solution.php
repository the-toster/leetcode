<?php

declare(strict_types=1);

namespace TheToster\Leetcode\Dynamic\BestTimeToBuyAndSellStockWithCooldown;


final class Solution
{
    /** @param int[] $prices */
    function maxProfit(array $prices): int
    {
        /**
         *
         * 1) Состояние динамики: параметр(ы), однозначно задающие подзадачу.
         * Состояния в которых можем находиться:
         * S0: готов покупать
         * S1: купил
         * S2: продал
         * для каждого шага храним макс прибыль на этом шаге
         * 2) Значения начальных состояний.
         * s0 = 0 - прибыли нет
         * s1 = -ц1 - в минусе после покупки
         * s2 = -inf - чтобы первое вычисленное состояние заменило его (будет типа S2[1] = max(s0, s1 + ц))
         * 3) Переходы между состояниями: формула пересчёта.
         * S0[i] = т.к. попасть в S0 можно или из S0 (остаться), или из S2, = max(S0[i - 1], S2[i - 1]);
         * S1[i] = т.к. попасть в S1 можно или из S1 (остаться, профит не меняется), или из S0 (купить, профит уменьшается), => max(S0[i - 1] - Ц[i], S1[i - 1]);
         * S2[i] = S1[1] + Ц[i] т.к. в "продал" можно попасть только купив, и профит увеличивается на сумму продажи
         * 4) Порядок пересчёта.
         * прямой
         * 5) Положение ответа на задачу: иногда это сумма или, например, максимум из значений нескольких состояний.
         * максимум из состояний на последний i
         */
        $last = count($prices) - 1;
        $wait = [0 => 0];
        $bought = [0 => -$prices[0]];
        $sold = [0 => PHP_INT_MIN];
        for ($i = 1; $i <= $last; $i++) {
            $cur = $prices[$i];
            $prevI = $i - 1;
            $wait[$i] = max($wait[$prevI], $sold[$prevI]);
            $bought[$i] = max($bought[$prevI], $wait[$prevI] - $cur);
            $sold[$i] = $bought[$prevI] + $cur;
        }

        return max($sold[$last], $wait[$last]);
    }
}
